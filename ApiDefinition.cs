namespace iOSBinding1
{

    // The first step to creating a binding is to add your native framework ("MyLibrary.xcframework")
    // to the project.
    // Open your binding csproj and add a section like this
    // <ItemGroup>
    //   <NativeReference Include="MyLibrary.xcframework">
    //     <Kind>Framework</Kind>
    //     <Frameworks></Frameworks>
    //   </NativeReference>
    // </ItemGroup>
    //
    // Once you've added it, you will need to customize it for your specific library:
    //  - Change the Include to the correct path/name of your library
    //  - Change Kind to Static (.a) or Framework (.framework/.xcframework) based upon the library kind and extension.
    //    - Dynamic (.dylib) is a third option but rarely if ever valid, and only on macOS and Mac Catalyst
    //  - If your library depends on other frameworks, add them inside <Frameworks></Frameworks>
    // Example:
    // <NativeReference Include="libs\MyTestFramework.xcframework">
    //   <Kind>Framework</Kind>
    //   <Frameworks>CoreLocation ModelIO</Frameworks>
    // </NativeReference>
    // 
    // Once you've done that, you're ready to move on to binding the API...
    //
    // Here is where you'd define your API definition for the native Objective-C library.
    //
    // For example, to bind the following Objective-C class:
    //
    //     @interface Widget : NSObject {
    //     }
    //
    // The C# binding would look like this:
    //
    //[BaseType(typeof(NSObject))]
    //interface Widget
    //{
    //}
    //
    // To bind Objective-C properties, such as:
    //
    //     @property (nonatomic, readwrite, assign) CGPoint center;
    //
    // You would add a property definition in the C# interface like so:
    //
    //     [Export ("center")]
    //     CGPoint Center { get; set; }
    //
    // To bind an Objective-C method, such as:
    //
    //     -(void) doSomething:(NSObject *)object atIndex:(NSInteger)index;
    //
    // You would add a method definition to the C# interface like so:
    //
    //[Export("doSomething:atIndex:")]
    //void DoSomething(NSObject object, nint index);

    // Objective-C "constructors" such as:
    //
    //     -(id)initWithElmo:(ElmoMuppet *)elmo;
    //
    // Can be bound as:
    //
    //[Export("initWithElmo:")]
    //NativeHandle Constructor(ElmoMuppet elmo);
    ////
    // For more information, see https://aka.ms/ios-binding
    //


    // typedef void (^XMUtilityCallback) (NSString *message);
    public delegate void XMUtilityCallback(NSString message);

    // @interface XMUtilities : NSObject
    [BaseType(typeof(NSObject))]
    interface XMUtilities
    {
        // NOTE:
        // We DO NOT have to bind a constructor since the default/empty
        // constructor will be automatically generated.
        //
        // -(id) init;
        //[Export("init")]
        //IntPtr Constructor();

        // NOTE:
        // This is attributed with static because it is a class/static method.
        //
        // +(NSString *) echo:(NSString *)message;
        [Static]
        [Export("echo:")]
        string Echo(string message);

        // NOTE:
        // Methods without a parameter do not need the trailing colon (":").
        //
        // -(NSString *) speak;
        [Export("speak")]
        string Speak();

        // -(NSString *) speak:(XMGreeting)greeting;
        [Export("speak:")]
        string Speak(XMGreeting greeting);

        // NOTE:
        // Methods WITH a parameter must have a trailing colon (":").
        //
        // -(NSString *) hello:(NSString *)name;
        [Export("hello:")]
        string Hello(string name);

        // NOTE:
        // Here we have two parameters, and the method name
        // and each argument are suffxed with a colon.
        //
        // -(NSInteger) add:(NSInteger)operandUn and:(NSInteger) operandDeux;
        [Export("add:and:")]
        nint Add(nint operandUn, nint operandDeux);

        // -(NSInteger) multiply:(NSInteger)operandUn and:(NSInteger)operandDeux;
        [Export("multiply:and:")]
        nint Multiply(nint operandUn, nint operandDeux);

        // -(void) setCallback:(XMUtilityCallback) callback;
        [Export("setCallback:")]
        void SetCallback(XMUtilityCallback callback);

        // -(void) invokeCallback:(NSString *) message;
        [Export("invokeCallback:")]
        void InvokeCallback(string message);
    }

    // NOTE:
    // We create a dummy I<DelegateName> here so we can reference it from the
    // delegate prperty and other members.
    interface IXMCustomViewDelegate { }

    // @protocol XMCustomViewDelegate<NSObject>
    [Protocol]
    [Model(AutoGeneratedName = true)]
    [BaseType(typeof(NSObject))]
    interface XMCustomViewDelegate
    {
        // NOTE:
        // The [Abstract] attribute is added since this is a required member.
        //
        // @required -(void)viewWasTouched:(UIView *)view;
        [Abstract]
        [Export("viewWasTouched:")]
        void ViewWasTouched(XMCustomView view);
    }

    // NOTE:
    // We want to turn the delegate members into events, so we set the 
    // attribute's "Delegates" property to the delegate property name
    // And, we set the attribute's "Events" property to the type of the
    // delegate.
    //
    // @interface XMCustomView : UIView
    [BaseType(typeof(UIView),
        Delegates = new[] { "Delegate" },
        Events = new[] { typeof(XMCustomViewDelegate) })]
    interface XMCustomView
    {
        // @property (nonatomic, strong) NSString* name;
        [Export("name")]
        string Name { get; [NullAllowed] set; }

        // NOTE:
        // Instead of using the class type, we use the interface as this will
        // be more flexible.
        //
        // @property (nonatomic, assign) id<XMCustomViewDelegate> delegate;
        [Export("delegate", ArgumentSemantic.Assign)]
        [NullAllowed]
        IXMCustomViewDelegate Delegate { get; set; }

        // NOTE:
        // The C# method name does not have to match the Objective-C name
        // because the attribute will be used to find it.
        //
        // -(void) customizeViewWithText:(NSString *)message;
        [Export("customizeViewWithText:")]
        void CustomizeView(string message);

        // NOTE:
        // This method uses the dummy interface because it accepts a protocol
        // and not a concrete type.
        //
        // -(void) doTouch:(id<XMCustomViewDelegate>)delegate;
        [Export("doTouch:")]
        void DoTouch(IXMCustomViewDelegate del);
    }


}
